module Simulator.Resource;

import Simulator.Prelude open;
import Data.ByteString open;
import Simulator.Kind open;

import Stdlib.Data.Int as Int;

--- A ;Resource; is an immutable object that represents part of an application's
--- state.
type Resource :=
  mkResource {
    -- The address of the ;Resource;'s logic function
    logicHash : LogicHash;
    -- Data which is relevant to the fungibility of the ;Resource;
    label : ByteString;
    -- Extra data which is not related to the fuungibility of the ;Resource;
    dynamicData : ByteString;
    -- An integer used to determine balance in transactions.
    quantity : Int
  };

open Resource;

-- --- Extract the data which determines the ;Resource;'s fungibility.
denomination (r : Resource) : Kind :=
  logicHash r :: label r;

-- --- Find all the resources associated with a denomination
resourcesForDenom (d : Kind) (rs : List Resource)
  : List Resource :=
  filter λ {r := Eq.eq (denomination r) d} rs;

--- Aggregate the quantities associated with a denomination
quantityOfDenom (d : Kind) (rs : List Resource)
  : Int :=
  for (acc := Int.ofNat 0) (r in resourcesForDenom d rs)
    quantity r + acc;

--- Return true if the list is empty or the list has exactly 1 element and the predicate is satisfied
zeroOrOneCheck : (Resource -> Bool) -> List Resource -> Bool
  | _ nil := true
  | p [x] := p x
  | _ _ := false;

exactlyOneCheck
  : (Resource -> Bool) -> List Resource -> Bool
  | p [x] := p x
  | _ _ := false;

type ResourceKind :=
  | created
  | consumed;

instance
eqResourceKind : Eq ResourceKind :=
  mkEq
    λ {
      | created created := true
      | consumed consumed := true
      | _ _ := false
    };

isCreated : ResourceKind -> Bool := Eq.eq created;

isConsumed : ResourceKind -> Bool := Eq.eq consumed;

instance
ordResource : Ord Resource :=
  let
    prod (r : Resource) : Kind × ByteString × Int :=
      denomination r, dynamicData r, quantity r;

    go (r1 : Resource) (r2 : Resource) : Ordering :=
      Ord.cmp (prod r1) (prod r2);
  in mkOrd go;
