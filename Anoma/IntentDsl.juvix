module Anoma.IntentDsl;

import Anoma.Prelude open hiding {for; any; all};
import Anoma open;

type Quantifier :=
  | Any
  | All;

type QuantifiedAssets :=
  mkAssets {
    quantifier : Quantifier;
    assets : List Asset
  };

syntax operator of_ additive;
syntax alias of_ := mkAsset;

type Intention :=
  | Want
  | Give;

type Clause :=
  mkClause {
    lhs : Intention × QuantifiedAssets;
    rhs : QuantifiedAssets
  };

any (as : List Asset) : QuantifiedAssets :=
  mkAssets@{
    quantifier := Any;
    assets := as
  };

all (as : List Asset) : QuantifiedAssets :=
  mkAssets@{
    quantifier := All;
    assets := as
  };

exactly (a : Asset) : QuantifiedAssets :=
  mkAssets@{
    quantifier := All;
    assets := [a]
  };

want
  (a : QuantifiedAssets) : Intention × QuantifiedAssets :=
  Want, a;

give
  (a : QuantifiedAssets) : Intention × QuantifiedAssets :=
  Give, a;

syntax operator for pair;

for
  (l : Intention × QuantifiedAssets)
  (qs : QuantifiedAssets)
  : Clause :=
  mkClause@{
    lhs := l;
    rhs := qs
  };

exchangeIntent (clauses : List Clause) : PartialTx :=
  mkPartialTx@{
    consumedResources :=
      concatMap clauseConsumedResources clauses;
    -- map (a in ownedAssets)
    --   mkSimpleResource (Asset.kind a) (Asset.quantity a);
    createdResources := []
  };

consumedAssets (clause : Clause) : QuantifiedAssets :=
  case Clause.lhs clause of {
    | Give, qas := qas
    | Want, _ := Clause.rhs clause
  };

clauseConsumedResources (clause : Clause) : List Resource :=
  map (a in QuantifiedAssets.assets (consumedAssets clause))
    mkSimpleResource (Asset.kind a) (Asset.quantity a);
